### 辅助函数
1.一般在app/helpers.php里写
例如 
    function test_helper(){
        return 'ok';
    }

2.引入
    在composer.json里的autoload里创建files字段
    "files":[
        'app/helpers.php'
    ]
    执行composer dumputoload
3.测试
    输入php artisan tinker
    输入test_helpers()






### 清除缓存
npm cache clean --force

### 安装依赖
npm install


## Laravel Mix
是一款前端任务自动化管理工具，使用了工作流的模式对制定好的任务依次执行。Mix支持许多常见的CSS与JS预处理器，使用Mix的前提是安装了npm依赖
### 在webpack.mix.js添加.versions(),每次Mix生成静态文件都会加上一个版本号，避免浏览器缓存
mix.js('resources/js/app.js', 'public/js')
  .vue()
  .sass('resources/sass/app.scss', 'public/css')
  .version();
### 编译mix文件,我们在resource/views里写的.blade.php文件 都需要通过mix继续编译，然后他会在public文件夹里生成样式，直接查看
npm run watch-poll ## 实时编译
npm run dev ##仅编译一次


## 用户认证功能
### Laravel自带了用户认证脚手架
### 创建用户认证页面
    php artisan ui:auth
    如果你已经在layouts里面自定义了主要布局文件——app.blade.php 那他提示是否需要覆盖的时候，你应该回答no![alt text](image.png)
### 会生成多余的home页面，所以我们要删除
    1.在routes/web.php 删除  Route::get('/home', 'HomeController@index')->name('home');
    2.删除app/Http/Controllers/HomeController.php 和 resources/views/home.blade.php两个文件
    3.将 app/Providers/RouteServiceProvicder.php 里的 public const HOME = '/home'; 改成 public const HOME = '/';
### 修改网站的.conf文件（nginx的话）
    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }

    修改成

    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }
### 加上邮箱验证功能
    1.在app/Models/User.php里加上 implements MustVerifyEmail
        class User extends Authenticatable implements MustVerifyEmail
    2.在routes/web.php修改
        // Laravel 的用户认证路由
        Auth::routes(['verify' => true]);
    3.再路由上加上verified中间件，如果一个未完成验证的用户尝试访问路由，中间件就会提示用户进行邮箱的验证
        例如：routes/web.php
        Route::get('/','PagesController@root')->name('root')->middleware('verified);
    4.配置MailHog，用于发送邮件进行验证
    4.使用qq邮箱进行发送
        1.登录qq邮箱->设置->账户->开启SMTP服务，获取授权码
        2.修改.env文件
            MAIL_MAILER=smtp
            MAIL_HOST=smtp.qq.com
            MAIL_PORT=465
            MAIL_USERNAME=1159543426@qq.com （这里是你的邮箱）
            MAIL_PASSWORD=fhyclpowlyqaibdd （这里是授权码）
            MAIL_ENCRYPTION=ssl
            MAIL_FROM_ADDRESS=1159543426@qq.com （这里是你的邮箱）
            MAIL_FROM_NAME="${APP_NAME}"
        3.安装ssl
            composer require guzzlehttp/guzzle


## 模型Modle
### 数据库迁移
    php artisan migrate
### 创建模型 -fm表示同时生成factory工厂文件和migration数据库迁移文件
    php artisan make:model UserAddress -fm
### 在数据迁移文件填写表的字段 
    public function up()
    {   
        //创建一个名为user_addresses的表
        Schema::create('user_addresses', function (Blueprint $table) {
            $table->bigIncrements('id'); //自增id 主键
            $table->unsignedBigInteger('user_id'); //改地址所属的用户id外键
            $table->foreign('user_id')->references('id')->on('users')->onDelete('cascade');
            $table->string('province'); //省
            $table->string('city'); //市
            $table->string('district'); //区
            $table->string('address'); //具体地址
            $table->unsignedInteger('zip'); //邮编
            $table->string('contact_name'); //联系人姓名
            $table->string('contact_phone'); //联系人电话
            $table->dateTime('last_used_at')->nullable(); //最后使用地址的时间
            $table->timestamps(); //创建时间戳
        });
    }
### 在模型UserAddress里可以填写要查询的字段、填写方法、填写数据的处理（拼接、转换大小写、修改数据等等）
    protected $fillable = [
        'province',
        'city',
        'district',
        'address',
        'zip',
        'contact_name',
        'contact_phone',
        'last_used_at',
    ];

    //与User模型进行关联 关联关系是一对多，就是可以有多个UserAddress对应一个User，但是一个UserAddress只属于一个User
    public function user()
    {
        return $this->belongsTo(User::class);
    }

    // 调用字段进行拼接，以后就可以直接访问getFullAddressAttribute()这个方法获取到用户的详细地址了
    public function getFullAddressAttribute()
    {
        return "{$this->province}{$this->city}{$this->district}{$this->address}";
    }
### factory工厂文件 用于快速生成假的数据用于测试
#### 配置中文（生成的数据变成中文） config/app.php
    'faker_locale' => 'zh_CN',
#### 编辑工厂文件 database/factories/XXXXFactory.php
    use App\Models\UserAddresses;
    ...
    //指定哪张表
    protected $model = UserAddress::class;
    public function definition()
    {
        $address = [
            ["北京市", "市辖区", "东城区"],
            ["河北省", "石家庄市", "长安区"],
            ["江苏省", "南京市", "浦口区"],
            ["江苏省", "苏州市", "相城区"],
            ["广东省", "深圳市", "福田区"],
        ];
        //randomElement()随机取出一个
        $address = $this->faker->randomElement($address);

        // $address[0]就是北京市 1就是市辖区 2就是东城区
        return [
            'provice'                => $address[0], 
            'city'                   => $address[1],
            'district'               => $address[2],
            'address'                => sprintf('第%d街道第%d号', $this->faker->randomNumber(2), $this->faker->randomNumber(3)),
            // 调用工厂里的内置函数
            'zip'                    => $this->faker->postcode,
            'contact_name'           => $this->faker->name,
            'contact_phone'          => $this->faker->phoneNumber,

        ];
    }
#### 执行工厂文件
    php artisan tinker

    // 只是创建了UserAddress对象，并没有保存到数据库中
    App\Models\UserAddress::factory()->make() 

    //create()可以把数据存入数据库，create()可以接收一个数组参数，数组中的数据会作为字段的值保存到数据库中，也就是说创建3条数据，并且他们的user_id都是1
    App\Models\UserAddress::factory()->count(3)->create(['user_id' => 1]) 



## Controller 控制器
### 创建控制器 
    php artisan make:controller UserAddressController
### 在控制器里添加方法
    public function index(Request $request)
    {
        /*
        * user_addresses.index 指的是在resources/views/user_addresses/index.blade.php
        * addresses 指的是通过$request调用user模型里的addresses方法，就是获取到UserAddresses的所有表里的数据，并且通过addresses这个词传给view模板使用
        */
        return view('user_addresses.index, [
            'addresses' => $request->user()->addresses,
        ]);
    }
### 跳转到指定路由
    public function tiaozhuan(){
        return redirect()->route('user_addresses.index');
    }


### 新增数据
    /*
    * $request->user() == Auth::user() 他们都是用来获取当前登录的用户是谁的
    * $user()->addresses() 通过User模型找到addresses()方法，而这个方法就是关联了address表的
    * create($request->only())  create创建一条数据，$request是根据UserAddressRequest规则 only只接收()里面传回来的数据，其他的不接受
    */
    public function store(UserAddressRequest $request) 
    {
        $request->user()->addresses()->create($request->only([
            'province',
            'city',
            'district',
            'address',
            'zip',
            'contact_name',
            'contact_phone',
        ]))
        return redirect()->route('user_addresses.index');
    }

### 访问该方法指定视图,并携带参数
#### 指定视图
    public function tiaozhuan(){
        return view('user_addresses.create_and_edit');
    }

#### 指定视图并携带参数给视图
    /*
    * 1.Laravel 会通过路由里的参数，例如user_addresses/1，把1提取出来
    * 2.之后会通过UserAddress模型，去数据查询id=1的UserAddress数据
    * 3.查询到数据之后，就会把数据一起给到视图，让他进行展示
    */
    public function tiaozhuan(UserAddress $user_address){
        return view('user_addresses.create_and_edit',['address' => $user_address]);
    }
    这时的路由就要写
    route::get('user_addresses/{user_address}','UserAddressesController@edit')->name('user_addresses.edit);

#### 修改数据，一般methods是put方法
    1.在route里写
        route::put('user_address/{user_address}', 'UserAddressesController@update')->name('user_address.update);
    2.在Controller要写
    /*
    * 1.laravel通过路由route截取到id，并且把id通过模型UserAddress找到对应的数据赋值给$user_address
    * 2.UserAddressRequest这个是提交数据的规则（哪些是必填的，哪些可以空出来）
    * 3.通过$user_address找到对应的数据，通过update进行修改，$request规则检验，only只接收([])里面的数据，其他的不接受
    */
    public function update(UserAddress $user_address, UserAddressRequest $reqeuest) {
        $user_address->update($request->only([
            'province',
            'city',
            'district',
            'address',
            'zip',
            'contact_name',
            'contact_phone',
        ]))

        return redirect()->route('user_address.index')
    }






## 视图
### 使用视图 $addresses是Controller里面指定的词
    @foreach($addresses as $address)
        <tr>
        <td>{{ $address->contact_name }}</td>
        <td>{{ $address->full_address }}</td>
        <td>{{ $address->zip }}</td>
        <td>{{ $address->contact_phone }}</td>
        <td>
            <button class="btn btn-primary">修改</button>
            <button class="btn btn-danger">删除</button>
        </td>
        </tr>
    @endforeach


## 路由
### 准备（开启命名空间）在app/Provides/RouteServiceProvider.php
把 protected $namespace = 'App\\Http\\Controllers' 这一行的注释解除
### 绑定路由在routes/web.php
这里是/根路由，对应的是PagesController里的root方法，并取别名root
Route::get('/', 'PagesController@root')->name('root')
### 添加组
    Route::group(['middleware' => ['auth','verified']], function() {
        // 访问的地址就是shop.test/user_addresses
        Route::get('user_addresses', 'UserAddressesController@index)->name('user_addresses.index');
    })



## 访问器 也可以称为计算属性
    通过方法动态生成树下的功能被称为访问器（Accessor）
### 在模型Modedl中定义一个：get{名称，例如FullName}Attribute()方法，laravel会自动转换，会在调用 $model->full_address 时，自动调用 getFullNameAttribute() 方法并返回其结果
    例如在UserAddress模型中定义访问器
    public function getFullAddressAttribute() {
        return '你好'
    }

    在Controller使用时，
    $address = UserAddress::find(1);
    echo $address->full_address; // 自动调用getFullAddressAttribute()

### $appends 当数据库里已经有full_name字段的时候，如果还想优先使用计算属性的full_name 可以使用$appends,强制优先使用访问器
    例如
    class User extends Model{
        protected $appends = ['full_name']
    }
### $hidden 隐藏原始字段，就是碰到如果跟数据库字段重名的时候，可以通过隐藏原始字段进行区分
    class User extends Model {
        protected $hidden = ['first_name', 'last_name']; // 隐藏原始字段
    }
### attributes 可以直接范文模型里的原始数据字段值
    public function getFullNameAttribute() {
        return "{$this->attributes['first_name']} {$this->attributes['last_name']}";
    }



## 数据校验
### 创建一个数据校验类
    php artisan make:request Request
### 编辑总校验类 开启校验 app/Http/Requests/Requests.php
    public function authorize()
    {
        return true;
    }
### 创建每个模型对应的校验类
    php artisan make:request UserAddressRequest
### 编辑规则 app/Http/Requests/UserAddressRequest.php
    public function rules()
    {
        return [
            'province'      => 'required',
            'city'          => 'required',
            'district'      => 'required',
            'address'       => 'required',
            'zip'           => 'required',
            'contact_name'  => 'required',
            'contact_phone' => 'required',
        ];
    }
### 修改校验为中文 汉化
    1.安装laravel-lang
        composer require overtrue/laravel-lang:*
    2.在config/app.php
        将 Illuminate\Translation\TranslationServiceProvider::class,
        替换 Overtrue\LaravelLang\TranslationServiceProvider::class,

        修改'locale' => 'zh_CN',



## 策略类（Policy）
### 通过授权策略类，权限控制，实现只要拥有者才能修改和删除地址
    php artisan make:policy UserAddressPolicy 位置在app/Policies
### 在生成的策略类编写方法
    App/Policies/UserAddressPolicy:
        use App\Models\UserAddress
        public function own(User $user, UserAddress $address) {
            return $address->user_id == $user->id
        }
### 编写函数 让Laravel自动寻找 模型对应的 授权策略文件
    app/Providers/AuthServiceProvider.php:
        public function boot()
        {
            $this->registerPolicies();

            //使用 Gate::guessPolicyNamesUsing 方法来寻找自定义策略文件
            Guess::guessPolicyNamesUsing(function ($class) {
                // class_basename 是 Laravel 提供的一个辅助函数， 可以获取类的简短名称
                // 例如传入 \App\Models\User 则会返回 User
                return 'App\\Policies\\'.class_basename($class).'Policy';
            })
        }

### 策略的使用
    在Controller
        public function edit(UserAddress $user_address)
        {
            $this->authorize('own', $user_address);
        }


### 后台管理 encore/laravel-admin 扩展包
    1.安装命令：composer require encore/laravel-admin "1.8.11"
    2.php artisan vendor:publish --provider="Encore\Admin\AdminServiceProvider"
    3.php artisan admin:install
